package hr.fer.zemris.java.nescume.messages.server.tests;

import hr.fer.zemris.java.nescume.messages.Address;
import hr.fer.zemris.java.nescume.messages.Message;
import hr.fer.zemris.java.nescume.messages.Message.MessageType;
import hr.fer.zemris.java.nescume.messages.client.ClientMsgService;
import hr.fer.zemris.java.nescume.messages.client.IClientMsgService;
import hr.fer.zemris.java.nescume.messages.client.exceptions.ClientCrashed;
import hr.fer.zemris.java.nescume.messages.client.exceptions.ClientException;
import hr.fer.zemris.java.nescume.messages.client.exceptions.MessageNotSent;
import hr.fer.zemris.java.nescume.messages.server.IMessageServer;
import hr.fer.zemris.java.nescume.messages.server.SocketMessageServer;
import hr.fer.zemris.java.nescume.messages.server.exceptions.ServerCannotStart;
import hr.fer.zemris.java.nescume.messages.server.exceptions.ServerCrashed;

import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Random;

import org.junit.AfterClass;
import org.junit.Assert;
import org.junit.BeforeClass;
import org.junit.Ignore;
import org.junit.Test;

import junit.framework.JUnit4TestAdapter;

/**
 * Klasa unit testova servera.
 */
public class ServerTests {

	/**
	 * Server.
	 */
	private static IMessageServer server;
	
	/**
	 * Lista klijenata.
	 */
	private static List<IClientMsgService> clients = new ArrayList<IClientMsgService>();
	
	/**
	 * Mapiranje klijenata na njihove adrese, tako da se zna tko što prima i kada.
	 */
	private static Map<IClientMsgService, Address> addresses = new HashMap<IClientMsgService, Address>();

	/**
	 * Zastavica koja javlja da li je server pokrenut (true) ili ne (false).
	 */
	private static boolean serverStarted = false;
	
	/**
	 * Broj klijenata kojima se testira server.
	 */
	private static final int NUMBER_OF_CLIENTS = 10;
	
	/**
	 * Broj nasumičnih poruka.
	 */
	private static final int NUMBER_OF_MESSAGES = 100;
	
	/**
	 * Metoda testira predavanje neispravnih parametara konstruktoru servera.
	 * @throws IOException u slučaju greške pri čitanju iz konfiguracijske datoteke
	 */
	@Test(expected = IllegalArgumentException.class)
	public void illegalParametersTest() throws IOException {
		Properties properties = new Properties();
				properties.load(new FileReader("configuration/server.properties"));
		
		properties.setProperty("packet.size", "-1");
		
		new SocketMessageServer(properties);
	}
	
	/**
	 * Metoda pokreće servera i klijente koji služe za testiranje.
	 * @throws IOException u slučaju greške pri čitanju
	 */
	@BeforeClass
	public static void startServerAndClients() throws IOException, ClientException {
		Properties serverProperties = new Properties();
		Properties clientProperties = new Properties();
		
		serverProperties.load(new FileReader("configuration/server.properties"));
		clientProperties.load(new FileReader("configuration/client.properties"));
		
		server = new SocketMessageServer(serverProperties);
		
		final Object mutex = new Object();
		
		new Thread(new Runnable() {
		
			public void run() {
				try {
					synchronized(mutex) {
						serverStarted = true;
						mutex.notifyAll();
					}
					
					server.start();
				} catch (ServerCannotStart e) {
					e.printStackTrace();
				} catch (ServerCrashed e) {
					e.printStackTrace();
				}
			}
		
		}).start();
		
		synchronized(mutex) {
			try {
				while(!serverStarted) {
					mutex.wait();
				}
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		
		for (int i = 0; i < NUMBER_OF_CLIENTS; i++) {
			IClientMsgService client = new ClientMsgService(clientProperties);
			
			addresses.put(client, client.register());
			
			clients.add(client);
		}
	}

	/**
	 * Metoda slučajnim odabirom šalje poruke od jednog klijenta do drugog. Samo jedan klijent
	 * šalje u nekom trenutku. Metoda testira ispravno dostavljanje.
	 */
	@Test
	@Ignore
	public void randomSendTest() throws ClientException {
		Random random = new Random();
		
		for (int i = 0; i < NUMBER_OF_MESSAGES; i++) {
			IClientMsgService sender = clients.get(random.nextInt(10));
			IClientMsgService receiver = clients.get(random.nextInt(10));
			
			Message sent = new Message(addresses.get(receiver), MessageType.LETTER, "Pozdrav!".getBytes());
<<<<<<< .mine
			sent.setUrgent(random.nextInt(100) > 50 ? true : false);
=======
>>>>>>> .r66
			
			sender.send(sent);
		
			Message received = receiver.receive();
			
			Assert.assertEquals("Primljena poruka nije jednaka poslanoj!", sent, received);
		}
	}
	
	private Message testMessage = new Message(addresses.get(clients.get(0)), MessageType.LETTER, "Pozdrav".getBytes());
	
	private Object mutex = new Object();
	
	public class IndependentClient implements Runnable {
		
		private IClientMsgService client;
		
		public IndependentClient(IClientMsgService client) {
			this.client = client;
			testMessage.setUrgent(true);
		}
		
		@Override
		public void run() {
			synchronized(mutex) {
				try {
					mutex.wait();
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			
			try {
				this.client.send(testMessage);
			} catch (MessageNotSent e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (ClientCrashed e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
	
	@Test
	public void manyToOneTest() throws ClientException {		
		for (int i = 1; i < NUMBER_OF_CLIENTS; i++) {
			new Thread(new IndependentClient(clients.get(i))).start();
		}
		
		synchronized(mutex) {
			mutex.notifyAll();
		}
		
		for (int i = 1; i < NUMBER_OF_CLIENTS; i++) {
			Message received = clients.get(0).receive();
			
			Assert.assertEquals("Tip poruke nije isti!", testMessage.getType(), received.getType());
			Assert.assertArrayEquals("Podaci poruke nisu isti!", testMessage.getData(), received.getData());
		}
	}
	
	/**
	 * Zaustavlja servera i klijente i čisti za njima.
	 */
	@AfterClass
	public static void stopServerAndClients() {
		for(IClientMsgService client : clients) {
			client.stop();
		}
		
		clients.clear();
		
		addresses.clear();
		
		server.stop();

		serverStarted = false;
	}
	
	/**
	 * Metoda potrebna za pozivanje testova iz ANT-a.
	 */
	public static junit.framework.Test suite() {
		return new JUnit4TestAdapter(ServerTests.class);
	}
}

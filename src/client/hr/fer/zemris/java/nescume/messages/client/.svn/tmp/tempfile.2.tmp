package hr.fer.zemris.java.nescume.messages.client;

import java.io.BufferedOutputStream;
import java.io.IOException;
import java.net.Socket;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.HashSet;
import java.util.Properties;
import java.util.Set;

import hr.fer.zemris.java.nescume.messages.Address;
import hr.fer.zemris.java.nescume.messages.Message;
import hr.fer.zemris.java.nescume.messages.Message.MessageType;
import hr.fer.zemris.java.nescume.messages.client.exceptions.ClientException;
import hr.fer.zemris.java.nescume.messages.client.exceptions.MessageNotSent;
import hr.fer.zemris.java.nescume.messages.client.exceptions.UnableToRegister;

/**
 * Klijent message service-a. Služi za komuniciranje sa serverom ili drugim
 * klijentima sustava.
 */
public class ClientMsgService implements IClientMsgService {

	/** Objekt koji sadrži IP servera, port servera i ID node-a klijenta. */
	private ClientParameters parametri;

	/** Socket za vezu prema serveru */
	private Socket socket;

	/** Buffer sa porukama. Poruke se šalju kad se buffer napuni. */
	private Set<Message> sendBuffer;

	/** Unikatna adresa klijenta. */
	private Address adresa;

	/**
	 * Konstruktor klijenta. Unutar konstruktora ostvaruje se veza prema
	 * serveru.
	 * 
	 * @param config
	 *            Objekt sa parametrima klijenta.
	 * @throws IOException
	 *             Ukoliko dođe do greške prilikom komunikacije s drugim
	 *             računalom.
	 * @throws UnknownHostException
	 *             Ukoliko se spajamo na host koji ne postoji ili nije dostupan.
	 * @throws IllegalArgumentException
	 *             Ukoliko su parametri klijenta neispravni.
	 * @throws SocketException
	 *             Ako se ne uspostavi konekcija unutar SOCKET_TIMEOUT vremena.
	 */
	public ClientMsgService(Properties config) throws UnknownHostException,
			IOException, IllegalArgumentException {
		this.parametri = new ClientParameters(config);
		this.socket = null;
		this.adresa = Address.parseGID(this.parametri.getClientGID());
		this.sendBuffer = new HashSet<Message>(this.parametri.getBufferSize());
	}

	// Implementacija metode sučelja
	public void start() {
		// Mislim da će ova metoda biti nepotrebna...
		// REPLY: a što će onda otvoriti vezu prema samom serveru, za to služi start, za
		// otvaranje veze, a sve dalje rade druge metode, kužiš, register samo pošalje poruku
	}

	// Implementacija metode sučelja
	public void stop() {
		if (this.socket != null) {
			try {
				this.socket.close();
			} catch (IOException zanemarivo) {
			}
		}
	}

	// Implementacija metode sučelja
	public Message receive() {
		// TODO Dodati primanje poruke sa servera.
		return null;
	}

	/**
	 * Pretplaćuje korisnika na jednu sljedeću poruku zadanog tipa.
	 * 
	 * @param type
	 *            Tip poruke na koju se korisnik pretplaćuje
	 */
	public void query(MessageType type) throws MessageNotSent {
		Message poruka = new Message(null, type, null);
		send(poruka);
	}

	/**
	 * Pretplaćuje korisnika na jednu sljedeću poruku zadanog tipa i zadanog
	 * sadržaja. Korisnik će dobiti samo onu poruku koja se podudara s oba
	 * parametra.
	 * 
	 * @param type
	 *            Tip poruke na koju se korisnik pretplaćuje
	 * @param data
	 *            Sadržaj poruke na koju se korisnik pretplaćuje
	 */
	public void query(MessageType type, byte[] data) throws MessageNotSent {
		Message poruka = new Message(null, type, data);
		send(poruka);
	}

	/**
	 * Pretplaćuje korisnika na više poruka zadanog tipa.<br />
	 * Broj poruka koje će klijent primiti određen je parametrom.
	 * 
	 * @param type
	 *            Tip poruke na koju se korisnik pretplaćuje
	 * @param count
	 *            Broj poruka na koje se klijent pretplaćuje.
	 */
	public void query(MessageType type, int count) throws MessageNotSent {
		Message poruka = new Message(null, type, null);
		for (int i = 1; i <= count; i++) {
			send(poruka);
		}
	}

	/**
	 * Pretplaćuje korisnika na više poruka zadanog tipa i zadanog sadržaja.
	 * Korisnik će dobiti samo one poruke koje se podudaraju s oba parametra.<br />
	 * Broj poruka koje će klijent primiti određen je parametrom.
	 * 
	 * @param type
	 *            Tip poruke na koju se korisnik pretplaćuje
	 * @param data
	 *            Sadržaj poruke na koju se korisnik pretplaćuje
	 * @param count
	 *            Broj poruka na koje se klijent pretplaćuje.
	 */
	public void query(MessageType type, byte[] data, int count)
			throws MessageNotSent {
		Message poruka = new Message(null, type, data);
		for (int i = 1; i <= count; i++) {
			send(poruka);
		}
	}

	// Implementacija metode sučelja
	public Address register() throws UnableToRegister {
		// TODO: Provjeri ispravnost metoda (odgovor.getDestination() me brine)
		// Ispravna je, tome i služe oni testovi, ali ako baš želiš, može.
		Message poruka = new Message(null, Message.MessageType.REGISTER, null);
		try {
			send(poruka);
		} catch (MessageNotSent e) {
			throw new UnableToRegister(this.adresa);
		}
		Message odgovor = receive();

		this.adresa = odgovor.getDestination();
		
		return this.adresa;
	}

	/**
	 * Slanje bufferiranih poruka.
	 * 
	 * @throws MessageNotSent
	 *             Ukoliko poruka nije poslana.
	 */
	private void izvrsiSlanje() throws MessageNotSent {
		try {
			if (this.socket == null) {
				spajanje();
			}
	
			// TODO: Možda dodati da MessageNotSend prima i Message kao argument.
			BufferedOutputStream bufferedOS = new BufferedOutputStream(
					this.socket.getOutputStream());

			for (Message msg : this.sendBuffer) {
				bufferedOS.write(msg.toByteArray());
			}
			bufferedOS.flush();
			bufferedOS.close();
		} catch (IOException e) {
			throw new MessageNotSent(this.adresa);
		} catch (ClientException ce) {
			throw new MessageNotSent(this.adresa, ce.getMessage());
		}
		this.sendBuffer.clear();
	}

	/**
	 * Spajanje na server.
	 * 
	 * @throws ClientException
	 */
	private void spajanje() throws ClientException {
		try {
			this.socket = new Socket(this.parametri.getServerIP(),
					this.parametri.getServerPort());
			this.socket.setSoTimeout(this.parametri.getSocketTimeout());
		} catch (UnknownHostException e) {
			throw new ClientException(this.adresa, "Ne mogu pronaći server: "
					+ this.parametri.getServerIP());
		} catch (SocketException e) {
			throw new ClientException(this.adresa, "Ne mogu se spojiti na server.");
		} catch (IOException e) {
			throw new ClientException(this.adresa, "Ne mogu se spojiti na server.");
		}
	}

	// Implementacija metode sučelja
	public void send(Message message) throws MessageNotSent {
		this.sendBuffer.add(message);

		if (this.sendBuffer.size() >= this.parametri.getBufferSize()) {
			izvrsiSlanje();
		}
	}

	// Implementacija metode sučelja
	public void sendUrgent(Message message) throws MessageNotSent {
		this.sendBuffer.add(message);

		izvrsiSlanje();
	}

	/**
	 * Klasa-container parametara klijenta.
	 */
	private class ClientParameters {

		/**
		 * Veličina send buffera. Poruke se šalju na server kad se buffer
		 * napuni.
		 */
		private int sendBufferSize;

		/**
		 * Nakon isteka ovog vremena (u milisekundama) šalju se sve poruke iz
		 * buffera na server (vrijeme se mjeri od zadnjeg dodavanja poruke u
		 * buffer).
		 */
		private int sendBufferTime;

		/**
		 * Vrijeme (u milisekundama) koje socket čeka na konekciju prije nego
		 * što baci SocketException exception.
		 */
		private int socketTimeout;

		/** Port preko kojeg se spajamo na server */
		private int serverPort;

		/** IP servera */
		private String serverIP;

		/** ID node-a na kojem se nalazi klijent */
		private int nodeID;

		/** GID klijenta u string zapisu */
		private String clientGID;

		/**
		 * Konstruktor.
		 * 
		 * @param config
		 *            Objekt koji sadrži IP servera, port servera i ID node-a
		 *            klijenta.
		 * @throws IllegalArgumentException
		 *             Ukoliko su parametri neispravni.
		 */
		public ClientParameters(Properties config)
				throws IllegalArgumentException {
			// TODO: Izvesto ovo ljepše...

			if (!config.containsKey("server.port")
					|| !config.containsKey("server.IP")
					|| !config.containsKey("node.ID")) {
				throw new IllegalArgumentException(
						"Niste zadali sve parametre potrebne klijentu (server port, server IP, node ID)!");
			}
			try {
				this.serverPort = Integer.parseInt((String) config
						.get("server.port"));
			} catch (NumberFormatException e) {
				throw new IllegalArgumentException("Neispravan server port!");
			}

			this.serverIP = (String) config.get("server.IP");
			if (!isValidIP(this.serverIP)) {
				throw new IllegalArgumentException("Neispravna IP adresa: "
						+ this.serverIP);
			}

			try {
				this.nodeID = Integer.parseInt((String) config.get("node.ID"));
			} catch (NumberFormatException e) {
				throw new IllegalArgumentException("Neispravan node ID!");
			}

			try {
				this.sendBufferSize = Integer.parseInt((String) config
						.get("buffer.size"));
			} catch (NumberFormatException e) {
				throw new IllegalArgumentException("Neispravan buffer size!");
			}

			try {
				this.sendBufferTime = Integer.parseInt((String) config
						.get("buffer.timeout"));
			} catch (NumberFormatException e) {
				throw new IllegalArgumentException("Neispravan buffer timeout!");
			}

			try {
				this.socketTimeout = Integer.parseInt((String) config
						.get("socket.timeout"));
			} catch (NumberFormatException e) {
				throw new IllegalArgumentException("Neispravan socket timeout!");
			}

			try {
				this.clientGID = (String) config.get("client.GID");
				if (!isValidGID(this.clientGID)) {
					throw new IllegalArgumentException("Neispravan GID: "
							+ this.clientGID);
				}
			} catch (NumberFormatException e) {
				throw new IllegalArgumentException("Neispravan client GID!");
			}
		}

		/**
		 * Getter server porta.
		 * 
		 * @return Port preko kojeg se spajamo na server.
		 */
		public int getServerPort() {
			return this.serverPort;
		}

		/**
		 * Getter IP-a servera.
		 * 
		 * @return IP servera.
		 */
		public String getServerIP() {
			return this.serverIP;
		}

		/**
		 * Getter node ID-a.
		 * 
		 * @return ID node-a na kojem se nalazi klijent.
		 */
		public int getNodeID() {
			return this.nodeID;
		}

		/**
		 * Getter sendBufferSize-a.
		 * 
		 * @return Broj poruka koje može primiti sendBuffer.
		 */
		public int getBufferSize() {
			return this.sendBufferSize;
		}

		/**
		 * Getter sendBufferTime-a.
		 * 
		 * @return Vrijeme (u milisekundama). Nakon isteka ovog vremena šalju se
		 *         poruke iz sendBuffera.
		 */
		public int getBufferTimeout() {
			return this.sendBufferTime;
		}

		/**
		 * Getter socketTimeout-a.
		 * 
		 * @return Vrijeme (u milisekundama). Ukoliko se klijent ne spoji na
		 *         server unutar ovog vremenskog intervala, baca se
		 *         socketException.
		 */
		public int getSocketTimeout() {
			return this.socketTimeout;
		}

		/**
		 * Getter client GID-a.
		 * 
		 * @return GID klijenta u string zapisu.
		 */
		public String getClientGID() {
			return this.clientGID;
		}

		/**
		 * Metoda za provjeru valjanosti IP-a.
		 * 
		 * @param IP
		 *            IP koji želimo provjeriti
		 * @return True ako IP predstavlja valjan IP, inače false.
		 */
		private boolean isValidIP(String IP) {
			String[] djelovi = IP.split(".");

			if (djelovi.length != 4) {
				return false;
			}

			try {
				for (int i = 0; i < 4; i++) {
					int dio = Integer.parseInt(djelovi[i]);
					if ((dio < 0) || (dio > 255))
						return false;
				}
			} catch (NumberFormatException e) {
				return false;
			}

			return true;
		}

		/**
		 * Metoda za provjeru valjanosti client GID-a.<br />
		 * Format GID-a je: "integer:integer"
		 * 
		 * @param clientGID
		 *            Tekstualni zapis client GID-a.
		 * @return True ako je zadani GID ispravan, inače false.
		 */
		private boolean isValidGID(String clientGID) {
			String[] dijeloviGIDa = clientGID.split(":");

			if (dijeloviGIDa.length != 2) {
				return false;
			}

			try {
				@SuppressWarnings("unused")
				int prviDio = Integer.parseInt(dijeloviGIDa[0]);
				@SuppressWarnings("unused")
				int drugiDio = Integer.parseInt(dijeloviGIDa[1]);
			} catch (NumberFormatException e) {
				return false;
			}

			return true;
		}
	}

	// Ovo je zasad samo ideja... sumnjam da je izvediva... zasad ostavljam
	// unutar komentara dok ne smislim što dalje.
	// private class Timer implements Runnable {
	//
	// /** Zastavica koja određuje aktivnost timera */
	// private boolean aktivan;
	//
	// /** Inicijaliziranje timera */
	// public void run() {
	// this.aktivan = false;
	// }
	//
	// /**
	// * "Odborojavanje" zadanog intervala.
	// *
	// * @param interval
	// * Vrijeme koje obrojava timer (u milisekundama).
	// */
	// public void startSleep(int interval) {
	//
	// }
	//
	// }
}

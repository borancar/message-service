package hr.fer.zemris.java.nescume.messages.client;

import java.io.IOException;
import java.net.Socket;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.HashSet;
import java.util.Properties;
import java.util.Set;

import hr.fer.zemris.java.nescume.messages.Address;
import hr.fer.zemris.java.nescume.messages.Message;
import hr.fer.zemris.java.nescume.messages.Message.MessageType;
import hr.fer.zemris.java.nescume.messages.client.exceptions.ClientCannotStart;
import hr.fer.zemris.java.nescume.messages.exceptions.BadParametersException;

/**
 * Klijent message service-a. Služi za komuniciranje sa serverom ili drugim
 * klijentima sustava.
 */
public class ClientMsgService implements IClientMsgService {

	/** Veličina send buffera. Poruke se šalju na server kad se buffer napuni. */
	// TODO: Postavi neku smislenu vrijednost
	private final int SEND_BUFFER_SIZE = 10;

	/**
	 * Nakon isteka ovog vremena (u milisekundama) šalju se sve poruke iz
	 * buffera na server (vrijeme se mjeri od zadnjeg dodavanja poruke u
	 * buffer).
	 */
	// TODO: Postavi neku smislenu vrijednost
	private final int SEND_BUFFER_TIME = 1000;

	/**
	 * Vrijeme (u milisekundama) koje socket čeka na konekciju prije nego što
	 * baci SocketException exception.
	 */
	private final int SOCKET_TIMEOUT = 3000;

	/** Objekt koji sadrži IP servera, port servera i ID node-a klijenta. */
	private ClientParameters parametri;

	/** Socket za vezu prema serveru */
	private Socket socket;

	/** Buffer sa porukama. Poruke se šalju kad se buffer napuni. */
	private Set<Message> sendBuffer;

	/**
	 * Konstruktor klijenta. Unutar konstruktora ostvaruje se veza prema
	 * serveru.
	 * 
	 * @param config
	 *            Objekt sa parametrima klijenta.
	 * @throws IOException
	 *             Ukoliko dođe do greške prilikom komunikacije s drugim
	 *             računalom.
	 * @throws UnknownHostException
	 *             Ukoliko se spajamo na host koji ne postoji ili nije dostupan.
	 * @throws BadParametersException
	 *             Ukoliko su parametri klijenta neispravni.
	 * @throws SocketException
	 *             Ako se ne uspostavi konekcija unutar SOCKET_TIMEOUT vremena.
	 */
	public ClientMsgService(Properties config) throws UnknownHostException,
			IOException, BadParametersException {
		this.parametri = new ClientParameters(config);
		this.socket = null;
		this.sendBuffer = new HashSet<Message>(SEND_BUFFER_SIZE);
	}

	// Implementacija metode sučelja
	public void start() {
		// TODO Mislim da će ova metoda biti nepotrebna...
	}

	// Implementacija metode sučelja
	public void stop() {
		if (this.socket != null) {
			try {
				this.socket.close();
			} catch (IOException zanemarivo) {
			}
		}
	}

	// Implementacija metode sučelja
	public Message receive() {
		// TODO Dodati primanje poruke sa servera.
		return null;
	}

	// Implementacija metode sučelja
	public void query(MessageType type) {
		Message poruka = new Message(null, type, null);
		send(poruka);
	}

	// Implementacija metode sučelja
	public void query(MessageType type, byte[] data) {
		Message poruka = new Message(null, type, data);
		send(poruka);
	}

	// Implementacija metode sučelja
	public void query(MessageType type, int count) {
		Message poruka = new Message(null, type, null);
		for (int i = 1; i <= count; i++) {
			send(poruka);
		}
	}

	// Implementacija metode sučelja
	public void query(MessageType type, byte[] data, int count) {
		Message poruka = new Message(null, type, data);
		for (int i = 1; i <= count; i++) {
			send(poruka);
		}
	}

	// Implementacija metode sučelja
	public Address register() {
		// TODO: Provjeri ispravnost metoda (odgovor.getDestination() me brine)
		Message poruka = new Message(null, Message.MessageType.REGISTER, null);
		send(poruka);
		Message odgovor = receive();

		return odgovor.getDestination();
	}

	/**
	 * Spajanje na server i slanje bufferiranih poruka.
	 */
	private void izvrsiSlanje() {
		if (this.socket == null) {
			try {
				this.socket = new Socket(this.parametri.getServerIP(),
						this.parametri.getServerPort());
				this.socket.setSoTimeout(SOCKET_TIMEOUT);
			} catch (UnknownHostException e) {
				// TODO Smisli što s exceptionima... ili ih sve "throw-ati" i
				// dodati u sučelje ili catch-at.
			} catch (SocketException e) {
				// TODO Smisli što s exceptionima... ili ih sve "throw-ati" i
				// dodati u sučelje ili catch-at.
			} catch (IOException e) {
				// TODO Smisli što s exceptionima... ili ih sve "throw-ati" i
				// dodati u sučelje ili catch-at.
			}
		}

		// TODO: Slanje podataka.
		// TODO: Smisli kako srediti slanje poruka s obzirom na istek vremena
		// (SEND_BUFFER_TIME)

		this.sendBuffer.clear();
	}

	// Implementacija metode sučelja
	public void send(Message message) {
		this.sendBuffer.add(message);

		if (this.sendBuffer.size() >= SEND_BUFFER_SIZE) {
			izvrsiSlanje();
		}
	}

	// Implementacija metode sučelja
	public void sendUrgent(Message message) {
		this.sendBuffer.add(message);

		izvrsiSlanje();
	}

	/**
	 * Klasa-container parametara klijenta.
	 */
	private class ClientParameters {

		/** Port preko kojeg se spajamo na server */
		private int serverPort;

		/** IP servera */
		private String serverIP;

		/** ID node-a na kojem se nalazi klijent */
		private int nodeID;

		/**
		 * Konstruktor.
		 * 
		 * @param config
		 *            Objekt koji sadrži IP servera, port servera i ID node-a
		 *            klijenta.
		 * @throws BadParametersException
		 *             Ukoliko su parametri neispravni.
		 */
		public ClientParameters(Properties config)
				throws BadParametersException {

			if (!config.containsKey("server.port")
					|| !config.containsKey("server.IP")
					|| !config.containsKey("node.ID")) {
				throw new BadParametersException(
						"Niste zadali sve parametre potrebne klijentu (server port, server IP, node ID)!");
			}
			try {
				this.serverPort = Integer.parseInt((String) config
						.get("server.port"));
			} catch (NumberFormatException e) {
				throw new BadParametersException("Neispravan server port!");
			}

			this.serverIP = (String) config.get("server.IP");
			if (!isValidIP(this.serverIP)) {
				throw new BadParametersException("Neispravna IP adresa: "
						+ this.serverIP);
			}

			try {
				this.nodeID = Integer.parseInt((String) config.get("node.ID"));
			} catch (NumberFormatException e) {
				throw new BadParametersException("Neispravan node ID!");
			}
		}

		/**
		 * Konstruktor.
		 * 
		 * @param serverPort
		 *            Port preko kojeg se spajamo na server.
		 * @param serverIP
		 *            IP servera.
		 * @param nodeID
		 *            ID node-a na kojem se nalazi klijent.
		 * @throws BadParametersException
		 *             Ukoliko su parametri neispravni.
		 */
		public ClientParameters(int serverPort, String serverIP, int nodeID)
				throws BadParametersException {
			this.serverPort = serverPort;
			this.serverIP = serverIP;
			this.nodeID = nodeID;

			if (serverPort < 1) {
				throw new BadParametersException(
						"Server port ne može biti manji od 0! Zadali ste: "
								+ serverPort);
			}

			if ((serverIP == null) || !isValidIP(serverIP)) {
				throw new BadParametersException("Neispravna IP adresa: "
						+ serverIP);
			}
		}

		/**
		 * Getter server porta.
		 * 
		 * @return Port preko kojeg se spajamo na server.
		 */
		public int getServerPort() {
			return this.serverPort;
		}

		/**
		 * Getter IP-a servera.
		 * 
		 * @return IP servera.
		 */
		public String getServerIP() {
			return this.serverIP;
		}

		/**
		 * Getter node ID-a.
		 * 
		 * @return ID node-a na kojem se nalazi klijent.
		 */
		public int getNodeID() {
			return this.nodeID;
		}

		/**
		 * Metoda za provjeru valjanosti IP-a.
		 * 
		 * @param IP
		 *            IP koji želimo provjeriti
		 * @return True ako IP predstavlja valjan IP, inače false.
		 */
		private boolean isValidIP(String IP) {
			String[] djelovi = IP.split(".");

			if (djelovi.length != 4) {
				return false;
			}

			try {
				for (int i = 0; i < 4; i++) {
					int dio = Integer.parseInt(djelovi[i]);
					if ((dio < 0) || (dio > 255))
						return false;
				}
			} catch (NumberFormatException e) {
				return false;
			}

			return true;
		}
	}
	
	// Ovo je zasad samo ideja... sumnjam da je izvediva... zasad ostavljam
	// unutar komentara dok ne smislim što dalje.
//	private class Timer implements Runnable {
//
//		/** Zastavica koja određuje aktivnost timera */
//		private boolean aktivan;
//
//		/** Inicijaliziranje timera */
//		public void run() {
//			this.aktivan = false;
//		}
//
//		/**
//		 * "Odborojavanje" zadanog intervala.
//		 * 
//		 * @param interval
//		 *            Vrijeme koje obrojava timer (u milisekundama).
//		 */
//		public void startSleep(int interval) {
//
//		}
//
//	}
}
